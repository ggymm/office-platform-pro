<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>netstat.md.html</title>
  <style>code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<div id="wrapper">  
<h1 id="netstat">netstat</h1>
<p>查看Linux中网络系统状态信息</p>
<h2 id="补充说明">补充说明</h2>
<p><strong>netstat命令</strong>
用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。</p>
<h3 id="语法">语法</h3>
<pre class="shell"><code>netstat(选项)</code></pre>
<h3 id="选项">选项</h3>
<pre class="shell"><code>-a或--all：显示所有连线中的Socket；
-A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址；
-c或--continuous：持续列出网络状态；
-C或--cache：显示路由器配置的快取信息；
-e或--extend：显示网络其他相关信息；
-F或--fib：显示FIB；
-g或--groups：显示多重广播功能群组组员名单；
-h或--help：在线帮助；
-i或--interfaces：显示网络界面信息表单；
-l或--listening：显示监控中的服务器的Socket；
-M或--masquerade：显示伪装的网络连线；
-n或--numeric：直接使用ip地址，而不通过域名服务器；
-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；
-o或--timers：显示计时器；
-p或--programs：显示正在使用Socket的程序识别码和程序名称；
-r或--route：显示Routing Table；
-s或--statistice：显示网络工作信息统计表；
-t或--tcp：显示TCP传输协议的连线状况；
-u或--udp：显示UDP传输协议的连线状况；
-v或--verbose：显示指令执行过程；
-V或--version：显示版本信息；
-w或--raw：显示RAW传输协议的连线状况；
-x或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同；
--ip或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。</code></pre>
<h3 id="实例">实例</h3>
<p><strong>列出所有端口 (包括监听和未监听的)</strong></p>
<pre class="shell"><code>netstat -a     #列出所有端口
netstat -at    #列出所有tcp端口
netstat -au    #列出所有udp端口                             </code></pre>
<p><strong>列出所有处于监听状态的 Sockets</strong></p>
<pre class="shell"><code>netstat -l        #只显示监听端口
netstat -lt       #只列出所有监听 tcp 端口
netstat -lu       #只列出所有监听 udp 端口
netstat -lx       #只列出所有监听 UNIX 端口</code></pre>
<p><strong>显示每个协议的统计信息</strong></p>
<pre class="shell"><code>netstat -s   显示所有端口的统计信息
netstat -st   显示TCP端口的统计信息
netstat -su   显示UDP端口的统计信息

​```shell

 **在netstat输出中显示 PID 和进程名称** 

​```shell
netstat -pt</code></pre>
<p><code>netstat -p</code>可以与其它开关一起使用，就可以添加“PID/进程名称”到netstat输出中，这样debugging的时候可以很方便的发现特定端口运行的程序。</p>
<p><strong>在netstat输出中不显示主机，端口和用户名(host, port or
user)</strong></p>
<p>当你不想让主机，端口和用户名显示，使用<code>netstat -n</code>。将会使用数字代替那些名称。同样可以加速输出，因为不用进行比对查询。</p>
<pre class="shell"><code>netstat -an</code></pre>
<p>如果只是不想让这三个名称中的一个被显示，使用以下命令:</p>
<pre class="shell"><code>netsat -a --numeric-ports
netsat -a --numeric-hosts
netsat -a --numeric-users</code></pre>
<p><strong>持续输出netstat信息</strong></p>
<pre class="shell"><code>netstat -c   #每隔一秒输出网络信息</code></pre>
<p><strong>显示系统不支持的地址族(Address Families)</strong></p>
<pre class="shell"><code>netstat --verbose</code></pre>
<p>在输出的末尾，会有如下的信息：</p>
<pre class="shell"><code>netstat: no support for `AF IPX&#39; on this system.
netstat: no support for `AF AX25&#39; on this system.
netstat: no support for `AF X25&#39; on this system.
netstat: no support for `AF NETROM&#39; on this system.</code></pre>
<p><strong>显示核心路由信息</strong></p>
<pre class="shell"><code>netstat -r</code></pre>
<p>使用<code>netstat -rn</code>显示数字格式，不查询主机名称。</p>
<p><strong>找出程序运行的端口</strong></p>
<p>并不是所有的进程都能找到，没有权限的会不显示，使用 root
权限查看所有的信息。</p>
<pre class="shell"><code>netstat -ap | grep ssh</code></pre>
<p>找出运行在指定端口的进程：</p>
<pre class="shell"><code>netstat -an | grep &#39;:80&#39;</code></pre>
<p><strong>通过端口找进程ID</strong></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">netstat</span> <span class="at">-anp</span><span class="kw">|</span><span class="fu">grep</span> 8081 <span class="kw">|</span> <span class="fu">grep</span> LISTEN<span class="kw">|</span><span class="fu">awk</span> <span class="st">&#39;{printf $7}&#39;</span><span class="kw">|</span><span class="fu">cut</span> <span class="at">-d</span>/ <span class="at">-f1</span></span></code></pre></div>
<p><strong>显示网络接口列表</strong></p>
<pre class="shell"><code>netstat -i</code></pre>
<p>显示详细信息，像是ifconfig使用<code>netstat -ie</code>。</p>
<p><strong>IP和TCP分析</strong></p>
<p>查看连接某服务端口最多的的IP地址：</p>
<pre class="shell"><code>netstat -ntu | grep :80 | awk &#39;{print $5}&#39; | cut -d: -f1 | awk &#39;{++ip[$1]} END {for(i in ip) print ip[i],&quot;\t&quot;,i}&#39; | sort -nr</code></pre>
<p>TCP各种状态列表：</p>
<pre class="shell"><code>netstat -nt | grep -e 127.0.0.1 -e 0.0.0.0 -e ::: -v | awk &#39;/^tcp/ {++state[$NF]} END {for(i in state) print i,&quot;\t&quot;,state[i]}&#39;</code></pre>
<p>查看phpcgi进程数，如果接近预设值，说明不够用，需要增加：</p>
<pre class="shell"><code>netstat -anpo | grep &quot;php-cgi&quot; | wc -l</code></pre>
<h2 id="扩展知识">扩展知识</h2>
<h3 id="网络连接状态详解">网络连接状态详解</h3>
<p><strong>共有12中可能的状态</strong>，前面11种是按照TCP连接建立的三次握手和TCP连接断开的四次挥手过程来描述的：</p>
<ol type="1">
<li><p>LISTEN：首先服务端需要打开一个socket进行监听，状态为
LISTEN，侦听来自远方TCP端口的连接请求 ；</p></li>
<li><p>SYN_SENT：客户端通过应用程序调用connect进行active
open，于是客户端tcp发送一个SYN以请求建立一个连接，之后状态置为
SYN_SENT，在发送连接请求后等待匹配的连接请求；</p></li>
<li><p>SYN_RECV：服务端应发出ACK确认客户端的
SYN，同时自己向客户端发送一个SYN，之后状态置为，在收到和发送一个连接请求后等待对连接请求的确认；</p></li>
<li><p>ESTABLISHED：代表一个打开的连接，双方可以进行或已经在数据交互了，
代表一个打开的连接，数据可以传送给用户；</p></li>
<li><p>FIN_WAIT1：主动关闭(active
close)端应用程序调用close，于是其TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态，
等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></li>
<li><p>CLOSE_WAIT：被动关闭(passive
close)端TCP接到FIN后，就发出ACK以回应FIN请求(它的接收也作为文件结束符传递给上层应用程序)，并进入CLOSE_WAIT，
等待从本地用户发来的连接中断请求；</p></li>
<li><p>FIN_WAIT2：主动关闭端接到ACK后，就进入了
FIN-WAIT-2，从远程TCP等待连接中断请求；</p></li>
<li><p>LAST_ACK：被动关闭端一段时间后，接收到文件结束符的应用程
序将调用CLOSE关闭连接，这导致它的TCP也发送一个
FIN,等待对方的ACK.就进入了LAST-ACK，等待原来发向远程TCP的连接中断请求的确认；</p></li>
<li><p>TIME_WAIT:在主动关闭端接收到FIN后，TCP
就发送ACK包，并进入TIME-WAIT状态，等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></li>
<li><p>CLOSING: 比较少见，等待远程TCP对连接中断的确认；</p></li>
<li><p>CLOSED:
被动关闭端在接受到ACK包后，就进入了closed的状态，连接结束，没有任何连接状态；</p></li>
<li><p>UNKNOWN：未知的Socket状态；</p></li>
</ol>
<p><strong>常见标志位</strong></p>
<ul>
<li><p>SYN: (同步序列编号,Synchronize Sequence
Numbers)该标志仅在三次握手建立TCP连接时有效。表示一个新的TCP连接请求。</p></li>
<li><p>ACK: (确认编号,Acknowledgement
Number)是对TCP请求的确认标志,同时提示对端系统已经成功接收所有数据。</p></li>
<li><p>FIN:
(结束标志,FINish)用来结束一个TCP回话.但对应端口仍处于开放状态,准备接收后续数据。</p></li>
</ul>
</div>
</body>
</html>